
!    Copyright (C) 2006 Imperial College London and others.
!    
!    Please see the AUTHORS file in the main source directory for a full list
!    of copyright holders.
!
!    Prof. C Pain
!    Applied Modelling and Computation Group
!    Department of Earth Science and Engineering
!    Imperial College London
!
!    amcgsoftware@imperial.ac.uk
!    
!    This library is free software; you can redistribute it and/or
!    modify it under the terms of the GNU Lesser General Public
!    License as published by the Free Software Foundation,
!    version 2.1 of the License.
!
!    This library is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!    Lesser General Public License for more details.
!
!    You should have received a copy of the GNU Lesser General Public
!    License along with this library; if not, write to the Free Software
!    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
!    USA
#include "fdebug.h"

  module multiphase_EOS

    use fldebug
    use state_module
    use fields
    use global_parameters, only: OPTION_PATH_LEN, PYTHON_FUNC_LEN
    use spud
    use futils, only: int2str
    use vector_tools
    use python_state
    use Copy_Outof_State

    use shape_functions_Linear_Quadratic
    use cv_advection
    use sparse_tools
    use Multiphase_module
    use sparsity_patterns_meshes, only : get_csr_sparsity_firstorder

    implicit none

    type corey_options
       REAL :: S_GC
       real :: S_OR
       real :: c
       real :: s_gi
       real :: cs_gi
       real :: kr1_max
       real :: kr2_max
       real :: kr1_exp
       real :: kr2_exp
       logical :: boost_at_zero_saturation
              
    end type corey_options

    type drag_option_type
       real :: diameter
       real :: coefficient
       logical :: is_quadratic
    end type drag_option_type

  contains

    subroutine Calculate_Phase_Component_Densities( state, &
         Density, Derivative, Density_Cp )
      implicit none
      type( state_type ), dimension( : ), intent( in ) :: state
      real, dimension( : ), intent( inout ) :: Density, Derivative, Density_Cp

!!$ Local variables
      type( scalar_field ), pointer :: pressure
      type( vector_field ), pointer :: positions
      character( len = option_path_len ), dimension( : ), allocatable :: eos_option_path
      integer :: nstates, nphase, ncomp, iphase, icomp, istate, nstate_init, nstate_final, cv_nonods
      logical :: is_multicomponent, is_multiphase, eos_from_components, eos_from_phases

      ewrite(3,*) 'In Calculate_Phase_Component_Densities'

!!$ Initialise
      Density = 0. ; Derivative = 0. ; Density_Cp = 0. 

!!$ Defining number of states from the schema (nstates)
      nstates = option_count( '/material_phase' )
      allocate( eos_option_path( nstates ) )

!!$ Let's assume that there are the same number of components in each phase
      ncomp = 0 ; is_multicomponent = .false. ; is_multiphase = .false.
      do istate = 1, nstates
         if( have_option( '/material_phase[' // int2str( istate - 1 ) // &
              ']/is_multiphase_component' ) ) then
            ncomp = ncomp + 1 ; is_multicomponent = .true.
         end if
      end do
      nphase = nstates - ncomp
      if( nphase > 1 ) is_multiphase = .true.
      assert( nphase > 0 ) ! Check if there is more than 0 phases

!!$ Obtaining control-volume Pressure field and boundary conditions (not necessary)
      pressure => extract_scalar_field( state(1), 'Pressure' )
      cv_nonods = node_count( pressure )

!!$ Defining the EOS for either each phase or each component:
      eos_from_components = .false. ; eos_from_phases = .false.
      Loop_Over_All_States: do istate = 1, nstates
         if( have_option( '/material_phase[' // int2str( istate - 1 ) // ']/equation_of_state' ) ) then
            if ( istate <= nphase ) then
               eos_from_phases = .true.
               if( eos_from_components ) &
                    FLAbort( 'EOS can be assigned for either Phases or Components. Not both, please check the mpml file')
            else
               eos_from_components = .true.
               if( eos_from_phases ) &
                    FLAbort( 'EOS can be assigned for either Phases or Components. Not both, please check the mpml file')
            end if

            eos_option_path( istate ) = trim( '/material_phase[' // int2str( istate - 1 ) // ']/equation_of_state' )
            call Assign_Equation_of_State( eos_option_path( istate ) )

         end if
      end do Loop_Over_All_States

      if ( eos_from_phases ) then
         nstate_init = 1 ; nstate_final = 1
      elseif( eos_from_components ) then
         nstate_init = nphase + 1 ; nstate_final =  nstates
      else
         FLAbort( 'Option not defined yet. A set of EOS need to be assigned.' )
      endif

      Loop_Over_Phases: do iphase = 1, nphase
         call Computing_Perturbation_Density( state, &
              iphase, nstate_init, nstate_final, eos_option_path, &
              Density( ( iphase - 1 ) * cv_nonods + 1 : iphase * cv_nonods ), &
              Derivative( ( iphase - 1 ) * cv_nonods + 1 : iphase * cv_nonods ), &
              DensityCpComponent_Field = Density_Cp( ( iphase - 1 ) * cv_nonods + 1 : iphase * cv_nonods ) )
      end do Loop_Over_Phases

      ewrite(3,*) 'Leaving Calculate_Phase_Component_Densities'

      return
    end subroutine Calculate_Phase_Component_Densities


    subroutine Assign_Equation_of_State( eos_option_path_out )
      implicit none
      character( len = option_path_len ), intent( inout ) :: eos_option_path_out

      Conditional_for_Compressibility: if( have_option( trim( eos_option_path_out ) // '/compressible' ) ) then
         eos_option_path_out = trim( eos_option_path_out ) // '/compressible'

         Conditional_for_Compressibility_Option: if( have_option( trim( eos_option_path_out ) // '/stiffened_gas' ) ) then
            eos_option_path_out = trim( eos_option_path_out ) // '/stiffened_gas'

         elseif( have_option( trim( eos_option_path_out ) // '/exponential_oil_gas' ) ) then
            eos_option_path_out = trim( eos_option_path_out ) // '/exponential_oil_gas'

         elseif( have_option( trim( eos_option_path_out ) // '/linear_in_pressure' ) ) then
            eos_option_path_out = trim( eos_option_path_out ) // '/linear_in_pressure'

            if( have_option( trim( eos_option_path_out ) // '/include_internal_energy' ) ) &
                 eos_option_path_out = trim( eos_option_path_out ) // '/include_internal_energy'

         elseif( have_option( trim( eos_option_path_out ) // '/exponential_in_pressure' ) ) then
            eos_option_path_out = trim( eos_option_path_out ) // '/exponential_in_pressure'

         else
            FLAbort( 'No option given for choice of EOS - compressible fluid' )

         end if Conditional_for_Compressibility_Option

      elseif( have_option( trim( eos_option_path_out ) // '/incompressible' ) )then
         eos_option_path_out = trim( eos_option_path_out ) // '/incompressible'

         Conditional_for_Incompressibility_Option: if( have_option( trim( eos_option_path_out ) // '/linear' ) ) then
            eos_option_path_out = trim( eos_option_path_out ) // '/linear'

         else
            FLAbort( 'No option given for choice of EOS - incompressible fluid' )

         end if Conditional_for_Incompressibility_Option

      elseif( have_option( trim( eos_option_path_out ) // '/python_state' ) ) then 
         eos_option_path_out = trim( eos_option_path_out ) // '/python_state'

      else

         FLAbort( 'No option given for choice of EOS' )

      end if Conditional_for_Compressibility

      return
    end subroutine Assign_Equation_of_State

    subroutine Computing_Perturbation_Density( state, &
         iphase, nstate_init, nstate_final, eos_option_path, &
         DensityComponent_Field, &
         Derivative_DensityComponent_Pressure, &
         Single_Component, DensityCpComponent_Field )
      implicit none
      type( state_type ), dimension( : ), intent( in ) :: state
      integer, intent( in ) :: iphase, nstate_init, nstate_final
      character( len = option_path_len ), dimension( : ), intent( in ) :: eos_option_path
      real, dimension( : ), intent( inout ) :: DensityComponent_Field, Derivative_DensityComponent_Pressure
      logical, optional :: Single_Component
      real, dimension( : ), intent( inout ), optional :: DensityCpComponent_Field
!!$ Local variables
      type( scalar_field ), pointer :: pressure, temperature, density, component, cp_s
      character( len = option_path_len ) :: option_path_comp, option_path_incomp, option_path_python, &
           option_path_component, option_path, buffer, eos_option_path_tmp
      character( len = python_func_len ) :: pycode
      integer :: nstates, istate, istate2, ncoef, stat
      logical, save :: initialised = .false.
      logical :: have_temperature_field, have_component_field
      real, parameter :: toler = 1.0E-10
      real, dimension( : ), allocatable, save :: reference_pressure
      real, dimension( : ), allocatable :: Density_Field, DRho_DPressure, eos_coefs, perturbation_pressure, &
           DensityPlus, DensityMinus, pressure_back_up, density_back_up, temperature_local, cp
      real :: dt, current_time
      integer :: nphase, ncomp, i

!!$ Den = c1 * ( P + c2 ) / T           :: Stiffened EOS
!!$ Den = c1 * P + c2                   :: Linear_1 EOS
!!$ Den = c1 * P / T + c2               :: Linear_2 EOS
!!$ Den = Den0 * exp[ c0 * ( P - P0 ) ] :: Exponential_1 EOS
!!$ Den = c0 * P** c1                   :: Exponential_2 EOS

      DensityComponent_Field = 0. ; Derivative_DensityComponent_Pressure = 0. 

      nstates = option_count( '/material_phase' )
      have_temperature_field = .false. ; have_component_field = .false.
      do istate = 1, nstates
         if( have_option( '/material_phase[' // int2str( istate - 1 ) // &
              ']/scalar_field::Temperature' ) ) have_temperature_field = .true.
         if( have_option( '/material_phase[' // int2str( istate - 1 ) // &
              ']/is_multiphase_component' ) .and. &
              have_option( '/material_phase[' // int2str( istate - 1 ) // &
              ']/equation_of_state') ) have_component_field = .true.
      end do
      ewrite(3,*) 'have_temperature_field, have_component_field::', &
           have_temperature_field, have_component_field

      pressure => extract_scalar_field( state( 1 ), 'Pressure' )
      if ( have_temperature_field ) &
           temperature => extract_scalar_field( state( iphase ), 'Temperature' )

      assert( node_count( pressure ) == size( DensityComponent_Field ) )
      allocate( Density_Field( node_count( pressure ) ), DRho_DPressure( node_count( pressure ) ) ) ; &
           Density_Field = 0. ; DRho_DPressure = 0. 
      allocate( perturbation_pressure( node_count( pressure ) ) ) ; perturbation_pressure = 0.
      allocate( DensityPlus( node_count( pressure ) ), DensityMinus( node_count( pressure ) ) ) ; &
           DensityPlus = 0. ; DensityMinus = 0.

      Loop_Over_States: do istate = nstate_init, nstate_final
         if( nstate_final == 1 ) then ! Phase density -- no components.
            istate2 = iphase
         else
            if( have_component_field ) then ! Component fields
               istate2 = istate 
               option_path_component = '/material_phase['  // int2str( istate2 - 1 ) // ']/is_multiphase_component'
               component => extract_scalar_field( state( istate2 ), 'ComponentMassFractionPhase' // &
                    int2str( iphase ) )
            end if
         end if

         if ( present_and_true( single_component ) ) then

            ncomp = 0
            do i = 1, size( state )
               if( have_option( '/material_phase[' // int2str( i - 1) // ']/is_multiphase_component' ) )then
                  ncomp = ncomp + 1
               end if
            end do
            nphase = size( state ) - ncomp

            option_path_comp   = trim( '/material_phase['  // int2str( nphase + nstate_init - 1 ) // ']/equation_of_state/compressible' )
            option_path_incomp = trim( '/material_phase['  // int2str( nphase + nstate_init  - 1 ) // ']/equation_of_state/incompressible' )
            option_path_python = trim( '/material_phase['  // int2str( nphase + nstate_init - 1 ) // ']/equation_of_state/python_state' )

            eos_option_path_tmp = trim( eos_option_path( 1 ) )

         else

            option_path_comp   = trim( '/material_phase['  // int2str( istate2 - 1 ) // ']/equation_of_state/compressible' )
            option_path_incomp = trim( '/material_phase['  // int2str( istate2 - 1 ) // ']/equation_of_state/incompressible' )
            option_path_python = trim( '/material_phase['  // int2str( istate2 - 1 ) // ']/equation_of_state/python_state' )
            eos_option_path_tmp = trim( eos_option_path( istate2 ) )

         end if

         Conditional_EOS_Option: if( trim( eos_option_path_tmp ) == trim( option_path_comp ) // '/stiffened_gas' ) then
!!$ Den = C0 / T * ( P - C1 )
            if( .not. have_temperature_field ) FLAbort( 'Temperature Field not defined' )
            allocate( eos_coefs( 2 ) ) ; eos_coefs = 0.
            call get_option( trim( eos_option_path_tmp // '/eos_option1' ), eos_coefs( 1 ) )
            call get_option( trim( eos_option_path_tmp // '/eos_option2' ), eos_coefs( 2 ) )
            Density_Field = ( pressure % val + eos_coefs( 1 ) ) * eos_coefs( 2 ) / temperature % val
            perturbation_pressure = max( toler, 1.e-3 * ( abs( pressure % val ) + eos_coefs( 1 ) ) )
            DensityPlus = ( pressure % val + perturbation_pressure + eos_coefs( 1 ) ) *  eos_coefs( 2 ) / &
                 temperature % val
            DensityMinus = ( pressure % val - perturbation_pressure + eos_coefs( 1 ) ) *  eos_coefs( 2 ) / &
                 temperature % val
            DRho_DPressure = 0.5 * ( DensityPlus - DensityMinus ) / perturbation_pressure
            deallocate( eos_coefs )

         elseif( trim( eos_option_path_tmp ) == trim( option_path_comp ) // '/linear_in_pressure' ) then
!!$ Den = C0 * P +C1
            allocate( eos_coefs( 2 ) ) ; eos_coefs = 0.
            call get_option( trim( eos_option_path_tmp ) // '/coefficient_A', eos_coefs( 1 ) )
            call get_option( trim( eos_option_path_tmp ) // '/coefficient_B', eos_coefs( 2 ) )
            Density_Field = eos_coefs( 1 ) * pressure % val + eos_coefs( 2 )
            perturbation_pressure = 1.
            !DensityPlus = eos_coefs( 1 ) * ( pressure % val + perturbation_pressure ) + eos_coefs( 2 )
            !DensityMinus = eos_coefs( 1 ) * ( pressure % val - perturbation_pressure ) + eos_coefs( 2 )
            DRho_DPressure = eos_coefs( 1 ) !0.5 * ( DensityPlus - DensityMinus ) / perturbation_pressure
            deallocate( eos_coefs )

         elseif( trim( eos_option_path_tmp ) == trim( option_path_comp ) // '/linear_in_pressure/include_internal_energy' ) then
!!$ Den = C0 * P/T +C1
            if( .not. have_temperature_field ) FLAbort( 'Temperature Field not defined' )
            allocate( eos_coefs( 2 ) ) ; eos_coefs = 0.
            call get_option( trim( option_path_comp ) // '/linear_in_pressure/coefficient_A', eos_coefs( 1 ) )
            call get_option( trim( option_path_comp ) // '/linear_in_pressure/coefficient_B', eos_coefs( 2 ) )
            Density_Field = eos_coefs( 1 ) * pressure % val / temperature % val + eos_coefs( 2 )
            perturbation_pressure = 1.
            !DensityPlus = eos_coefs( 1 ) * ( pressure % val + perturbation_pressure ) / &
            !     ( max( toler, temperature % val ) ) + eos_coefs( 2 )
            !DensityMinus = eos_coefs( 1 ) * ( pressure % val - perturbation_pressure ) / &
            !     ( max( toler, temperature % val ) ) + eos_coefs( 2 )
            DRho_DPressure =  eos_coefs( 1 ) / temperature % val !0.5 * ( DensityPlus - DensityMinus ) / perturbation_pressure
            deallocate( eos_coefs )

         elseif( trim( eos_option_path_tmp ) == trim( option_path_comp ) // '/exponential_oil_gas' ) then
!!$ Den = Den0 * Exp[ C0 * ( P - P0 ) ]
            allocate( eos_coefs( 2 ) ) ; eos_coefs = 0.
            call get_option( trim( eos_option_path_tmp ) // '/compressibility', eos_coefs( 1 ) )   ! compressibility_factor 
            call get_option( trim( eos_option_path_tmp ) // '/reference_density', eos_coefs( 2 ) ) ! reference_density 
            if ( .not. initialised ) then
               allocate( reference_pressure( node_count( pressure ) ) )
               reference_pressure = pressure % val
               initialised = .true.
            end if
            Density_Field = eos_coefs( 2 ) * exp( eos_coefs( 1 ) * ( pressure % val - reference_pressure ) )
            perturbation_pressure = max( toler, 1.e-3 * ( abs( pressure % val ) ) )
            DensityPlus = eos_coefs( 2 ) * exp( eos_coefs( 1 ) * ( ( pressure % val + perturbation_pressure ) - &
                 reference_pressure ) ) 
            DensityMinus = eos_coefs( 2 ) * exp( eos_coefs( 1 ) * ( ( pressure % val - perturbation_pressure ) - &
                 reference_pressure ) ) 
            DRho_DPressure = 0.5 * ( DensityPlus - DensityMinus ) / perturbation_pressure
            deallocate( eos_coefs )

         elseif( trim( eos_option_path_tmp ) == trim( option_path_comp ) // '/exponential_in_pressure' ) then 
!!$ Den = C0 * ( P ^ C1 )
            allocate( eos_coefs( 2 ) ) ; eos_coefs = 0.
            call get_option( trim( eos_option_path_tmp ) // '/coefficient_A', eos_coefs( 1 ) )
            call get_option( trim( eos_option_path_tmp ) // '/coefficient_B', eos_coefs( 2 ) )
            Density_Field = eos_coefs( 1 ) * pressure % val ** eos_coefs( 2 )
            perturbation_pressure = 1.
            DensityPlus = eos_coefs( 1 ) * ( pressure % val + perturbation_pressure ) ** eos_coefs( 2 )
            DensityMinus = eos_coefs( 1 ) * ( pressure % val - perturbation_pressure ) ** eos_coefs( 2 )
            DRho_DPressure = 0.5 * ( DensityPlus - DensityMinus ) / perturbation_pressure
            deallocate( eos_coefs )

         elseif( trim( eos_option_path_tmp ) == trim( option_path_incomp ) // '/linear' ) then
!!$ Polynomial representation
            allocate( temperature_local( node_count( pressure ) ) ) ; temperature_local = 0.
            if ( have_temperature_field ) temperature_local = temperature % val
            ncoef = 10 ; allocate( eos_coefs( ncoef ) ) ; eos_coefs = 0.
            if( have_option( trim( eos_option_path_tmp ) // '/all_equal' ) ) then
               call get_option( trim( eos_option_path_tmp ) // '/all_equal', eos_coefs( 1 ) )
               eos_coefs( 2 : 10 ) = 0.
            elseif( have_option( trim( eos_option_path_tmp ) // '/specify_all' ) ) then
               call get_option( trim( eos_option_path_tmp ) // '/specify_all', eos_coefs )
            else
               FLAbort('Unknown incompressible linear equation of state')
            end if
            call Density_Polynomial( eos_coefs, pressure % val, temperature_local, &
                 Density_Field )
            perturbation_pressure = max( toler, 1.e-3 * abs( pressure % val ) )
            call Density_Polynomial( eos_coefs, pressure % val + perturbation_pressure, temperature_local, &
                 DensityPlus )
            call Density_Polynomial( eos_coefs, pressure % val - perturbation_pressure, temperature_local, &
                 Densityminus )
            DRho_DPressure = 0.5 * ( DensityPlus - DensityMinus ) / perturbation_pressure
            deallocate( temperature_local, eos_coefs )

         elseif( trim( eos_option_path_tmp ) == trim( option_path_python ) ) then

#ifdef HAVE_NUMPY
            ewrite(3,*) "Have both NumPy and a python eos..."
#else
            FLAbort("Python eos requires NumPy, which cannot be located.")
#endif

            density => extract_scalar_field( state( iphase ), "Density" )         
            call zero( density )

            call python_reset()
            call python_add_state( state( iphase ) )

            call python_run_string("field = state.scalar_fields['Density']")
            call get_option("/timestepping/current_time", current_time)
            write(buffer,*) current_time
            call python_run_string("time="//trim(buffer))
            call get_option("/timestepping/timestep", dt)
            write(buffer,*) dt
            call python_run_string("dt="//trim(buffer))  

            ! Get the code
            call get_option( trim( option_path_python ) // '/algorithm', pycode )

            ! Run the code
            call python_run_string( trim( pycode ) )

            ! Copy result to protoype memory
            Density_Field = density % val

            ! Back up pressure and density before we start perturbing stuff... 
            allocate( pressure_back_up( node_count( pressure ) ), density_back_up( node_count( pressure ) ) )
            pressure_back_up = 0. ; density_back_up = 0.
            pressure_back_up = pressure % val
            density_back_up = density % val

            call python_reset()

            ! Calculating d(den) / dP
            ! redefine p as p+pert and p-pert and then run python state again to get the d(den) / d P...
            perturbation_pressure = 1.e-5

            pressure % val = pressure % val + perturbation_pressure
            call zero( density )

            call python_reset()
            call python_add_state( state( iphase ) )

            call python_run_string("field = state.scalar_fields['Density']")

            call get_option("/timestepping/current_time", current_time)
            write(buffer,*) current_time
            call python_run_string("time="//trim(buffer))
            call get_option("/timestepping/timestep", dt)
            write(buffer,*) dt
            call python_run_string("dt="//trim(buffer))  

            call python_run_string(trim(pycode))
            DensityPlus = density % val

            call python_reset()

            pressure % val = pressure_back_up
            pressure % val = pressure % val - perturbation_pressure
            call zero( density )

            call python_reset()
            call python_add_state( state( iphase ) )

            call python_run_string("field = state.scalar_fields['Density']")

            call get_option("/timestepping/current_time", current_time)
            write(buffer,*) current_time
            call python_run_string("time="//trim(buffer))
            call get_option("/timestepping/timestep", dt)
            write(buffer,*) dt
            call python_run_string("dt="//trim(buffer))

            call python_run_string(trim(pycode))
            DensityMinus = density % val

            call python_reset()

            ! derivative
            DRho_DPressure = 0.5 * ( DensityPlus - DensityMinus ) / perturbation_pressure

            ! Restore pressure and density values in state
            pressure % val = pressure_back_up
            density % val = density_back_up

            deallocate( pressure_back_up, density_back_up )

         else
            FLAbort( 'No option given for choice of EOS' )
         end if Conditional_EOS_Option

         if ( present_and_true( single_component ) ) then

            DensityComponent_Field = Density_Field
            Derivative_DensityComponent_Pressure = DRho_DPressure / DensityComponent_Field

         else

            if( have_component_field ) then

               cp_s => extract_scalar_field( state( istate2 ), &
                    'ComponentMassFractionPhase' // int2str( iphase ) // 'HeatCapacity', stat  )

               allocate( cp( node_count( pressure ) ) ) ; cp = 1.
               if( stat == 0 ) cp = cp_s % val

               DensityComponent_Field = DensityComponent_Field + Density_Field * component % val

               if ( present( DensityCpComponent_Field ) ) &
                    DensityCpComponent_Field = DensityCpComponent_Field + Density_Field * component % val * cp

               Derivative_DensityComponent_Pressure = Derivative_DensityComponent_Pressure + &
                    DRho_DPressure * component % val

               deallocate( cp )

            else
               DensityComponent_Field = Density_Field
               Derivative_DensityComponent_Pressure = DRho_DPressure
            end if

         end if

      end do Loop_Over_States

      deallocate( perturbation_pressure, DensityPlus, DensityMinus )

      return
    end subroutine Computing_Perturbation_Density

    subroutine Density_Polynomial( eos_coefs, pressure, temperature, &
         Density_Field )
      implicit none
      real, dimension( : ), intent( in ) :: eos_coefs, pressure, temperature
      real, dimension( : ), intent( inout ) :: Density_Field

      Density_Field = eos_coefs( 1 ) + eos_coefs( 2 ) * pressure + eos_coefs( 3 ) * temperature + &
           eos_coefs( 4 ) * pressure * temperature + eos_coefs( 5 ) * pressure **2 + &
           eos_coefs( 6 ) * temperature **2 + eos_coefs( 7 ) * ( pressure ** 2 ) * temperature + &
           eos_coefs( 8 ) * ( temperature ** 2 ) * pressure + &
           eos_coefs( 9 ) * ( temperature ** 2 ) * ( pressure ** 2 )

      return
    end subroutine Density_Polynomial



    SUBROUTINE CAL_CPDEN( NPHASE, CV_NONODS, CV_PHA_NONODS, CPDEN, DEN, NCP_COEFS, &
         CP_COEFS, CP_OPTION, STOTEL, CV_SNLOC, SUF_CPD_BCU, SUF_D_BCU ) 

      ! This sub calculates the CPDEN ie. CP*DEN
      IMPLICIT NONE
      INTEGER, intent( in ) :: NPHASE, CV_NONODS, CV_PHA_NONODS, NCP_COEFS, STOTEL, CV_SNLOC
      REAL, DIMENSION( CV_PHA_NONODS ), intent( in ) :: DEN
      REAL, DIMENSION( CV_PHA_NONODS ), intent( inout ) :: CPDEN
      REAL, DIMENSION( STOTEL * CV_SNLOC * NPHASE ), intent( in ) :: SUF_D_BCU
      REAL, DIMENSION( STOTEL * CV_SNLOC * NPHASE ), intent( inout ) :: SUF_CPD_BCU
      REAL, DIMENSION( NPHASE, NCP_COEFS ), intent( in ) :: CP_COEFS
      INTEGER, DIMENSION( NPHASE ), intent( in ) ::  CP_OPTION
      ! Local
      INTEGER :: IPHASE, CV_NOD, CV_NOD_IPHA, IS_IPHA, II

      Loop_Phase1: DO IPHASE = 1, NPHASE

         Loop_CV: DO CV_NOD = 1, CV_NONODS

            CV_NOD_IPHA = CV_NOD + ( IPHASE - 1 ) * CV_NONODS

            IF( CP_OPTION( IPHASE ) == 1 ) THEN
               CPDEN( CV_NOD_IPHA ) = CP_COEFS( IPHASE, 1 ) * DEN( CV_NOD_IPHA )
            ELSE
               FLAbort("Invalid integer for Element CP_Coefs")
            ENDIF

         END DO Loop_CV

      END DO Loop_Phase1

      ! For the b.c's
      Loop_Surfaces: DO II = 1, STOTEL * CV_SNLOC

         Loop_Phase2: DO IPHASE = 1, NPHASE
            IS_IPHA = II + ( IPHASE - 1 ) * NPHASE

            IF( CP_OPTION( IPHASE ) == 1 ) THEN
               SUF_CPD_BCU( IS_IPHA ) = CP_COEFS( IPHASE, 1 ) * SUF_D_BCU( IS_IPHA )
            ELSE
               FLAbort("Invalid integer for Surface CP_Coefs")
            ENDIF

         END DO Loop_Phase2
      END DO Loop_Surfaces

      RETURN

    END SUBROUTINE CAL_CPDEN



    subroutine Calculate_AbsorptionTerm( state, &
         cv_ndgln, mat_ndgln, &
         satura, perm, &
         nopt_vel_upwind_coefs, opt_vel_upwind_coefs, u_absorb )
      ! Calculate absorption for momentum eqns
      use matrix_operations
      implicit none
      type( state_type ), dimension( : ), intent( inout ) :: state
      integer, dimension( : ), intent( in ) :: cv_ndgln, mat_ndgln
      real, dimension( : ), intent( in ) :: satura
      real, dimension( :, :, : ), intent( in ) :: perm
      integer, intent( in ) :: nopt_vel_upwind_coefs
      real, dimension( nopt_vel_upwind_coefs ), intent( inout ) :: opt_vel_upwind_coefs
      real, dimension( :, :, : ), intent( inout ) :: u_absorb
!!$ Local variables:
      type( tensor_field ), pointer :: viscosity_ph1, viscosity_ph2
      integer :: nphase, nstate, ncomp, totele, ndim, stotel, &
           u_nloc, xu_nloc, cv_nloc, x_nloc, x_nloc_p1, p_nloc, mat_nloc, x_snloc, cv_snloc, u_snloc, &
           p_snloc, cv_nonods, mat_nonods, u_nonods, xu_nonods, x_nonods, x_nonods_p1, p_nonods, &
           ele, imat, icv, iphase, cv_iloc, idim, jdim, ij,i
      real :: Mobility, pert
      real, dimension( :, :, : ), allocatable :: u_absorb2
      real, dimension( : ), allocatable :: satura2

      logical, dimension(size(state)) :: drag_term
      integer :: continuous_phase
      type(drag_option_type), dimension(size(state)) :: drag_options
      type(block_csr_matrix) :: drag_abs_matrix

!!$ Obtaining a few scalars that will be used in the current subroutine tree:
      call Get_Primary_Scalars( state, &         
           nphase, nstate, ncomp, totele, ndim, stotel, &
           u_nloc, xu_nloc, cv_nloc, x_nloc, x_nloc_p1, p_nloc, mat_nloc, &
           x_snloc, cv_snloc, u_snloc, p_snloc, &
           cv_nonods, mat_nonods, u_nonods, xu_nonods, x_nonods, x_nonods_p1, p_nonods )


      ewrite(3,*) 'In calculate_absorption'

      if( have_option( '/physical_parameters/mobility' ) )then
         call get_option( '/physical_parameters/mobility', Mobility )
      elseif( have_option( '/material_phase[1]/vector_field::Velocity/prognostic/tensor_field::Viscosity' // &
           '/prescribed/value::WholeMesh/isotropic' ) ) then
         viscosity_ph1 => extract_tensor_field( state( 1 ), 'Viscosity' )
         viscosity_ph2 => extract_tensor_field( state( 2 ), 'Viscosity' )
         Mobility =  viscosity_ph2%val( 1, 1, 1 ) / viscosity_ph1%val( 1, 1, 1 )
      elseif( nphase == 1 ) then
         Mobility = 0.
      end if

      allocate( u_absorb2( mat_nonods, nphase * ndim, nphase * ndim ), satura2( cv_nonods * nphase ) )
      u_absorb2 = 0. ; satura2 = 0.

      CALL calculate_absorption2( MAT_NONODS, CV_NONODS, NPHASE, NDIM, SATURA, TOTELE, CV_NLOC, MAT_NLOC, &
           CV_NDGLN, MAT_NDGLN, &
           U_ABSORB, PERM, MOBILITY)

      PERT = 0.0001
      SATURA2( 1 : CV_NONODS ) = SATURA( 1 : CV_NONODS ) + PERT
      IF ( NPHASE > 1 ) SATURA2( 1 + CV_NONODS : 2 * CV_NONODS ) = SATURA( 1 + CV_NONODS : 2 * CV_NONODS ) - PERT

      CALL calculate_absorption2( MAT_NONODS, CV_NONODS, NPHASE, NDIM, SATURA2, TOTELE, CV_NLOC, MAT_NLOC, &
           CV_NDGLN, MAT_NDGLN, &
           U_ABSORB2, PERM, MOBILITY)

      continuous_phase=1
      drag_term=.false.
      do IPHASE = 1, NPHASE
         if( have_option( '/material_phase['//int2str(IPHASE-1)//']/' // &
           '/multiphase_properties/continuous_phase' ) ) continuous_phase=IPHASE
         if( have_option( '/material_phase['//int2str(IPHASE-1)//']/' // &
           '/multiphase_properties/drag' ) ) then
            call get_drag_options(iphase,state(iphase), drag_options(iphase))
            drag_term=.true.
         end if
      end do
         
      if (any(drag_term)) then
         call initialize_drag_matrix(drag_abs_matrix,state(continuous_phase),nphase)
         do IPHASE = 1, NPHASE
            if (drag_term(iphase)) then
               call add_drag_term(state,drag_abs_matrix,iphase,continuous_phase,drag_options(iphase))
            end if
         end do
         call add_drag_to_old_style_matrix_and_cleanup(drag_abs_matrix,U_ABSORB,state(continuous_phase),&
              MAT_NONODS, CV_NONODS, NPHASE, NDIM, TOTELE, CV_NLOC, MAT_NLOC, &
           CV_NDGLN, MAT_NDGLN)
      end if

      DO ELE = 1, TOTELE
         DO CV_ILOC = 1, CV_NLOC
            IMAT = MAT_NDGLN(( ELE - 1 ) * MAT_NLOC +CV_ILOC )
            ICV = CV_NDGLN(( ELE - 1 ) * CV_NLOC + CV_ILOC )
            DO IPHASE = 1, NPHASE
               DO IDIM = 1, NDIM
                  DO JDIM = 1, NDIM
                     IJ = ( IPHASE - 1 ) * MAT_NONODS * NDIM * NDIM + ( IMAT - 1 ) * NDIM * NDIM + &
                          ( IDIM - 1 ) * NDIM + JDIM
                     OPT_VEL_UPWIND_COEFS( IJ ) &
                          = U_ABSORB( IMAT, IDIM + ( IPHASE - 1 ) * NDIM, JDIM + ( IPHASE - 1 ) * NDIM ) 
                     ! This is the gradient...
                     OPT_VEL_UPWIND_COEFS( IJ + NPHASE * MAT_NONODS * NDIM * NDIM ) &
                          = ( U_ABSORB2( IMAT, IDIM + ( IPHASE - 1 ) * NDIM, JDIM + ( IPHASE - 1 ) * NDIM ) &
                          - U_ABSORB( IMAT, IDIM + ( IPHASE - 1 ) * NDIM, JDIM + ( IPHASE - 1 ) * NDIM ) )  &
                          / ( SATURA2( ICV + ( IPHASE - 1 ) * CV_NONODS ) - SATURA( ICV + ( IPHASE - 1 ) * CV_NONODS ) ) 
                  END DO
               END DO
            END DO
         END DO
      END DO

      deallocate( u_absorb2, satura2 )
      ewrite(3,*) 'Leaving calculate_absorption'

      RETURN

    END SUBROUTINE Calculate_AbsorptionTerm




    SUBROUTINE calculate_absorption2( MAT_NONODS, CV_NONODS, NPHASE, NDIM, SATURA, TOTELE, CV_NLOC, MAT_NLOC, &
         CV_NDGLN, MAT_NDGLN, &
         U_ABSORB, PERM2, MOBILITY) 
      ! Calculate absorption for momentum eqns
      use matrix_operations
      !    use cv_advection
      implicit none
      INTEGER, intent( in ) :: MAT_NONODS, CV_NONODS, NPHASE, NDIM, TOTELE, CV_NLOC,MAT_NLOC
      REAL, DIMENSION( CV_NONODS * NPHASE ), intent( in ) :: SATURA
      INTEGER, DIMENSION( TOTELE * CV_NLOC ), intent( in ) :: CV_NDGLN
      INTEGER, DIMENSION( TOTELE * MAT_NLOC ), intent( in ) :: MAT_NDGLN
      REAL, DIMENSION( MAT_NONODS, NDIM * NPHASE, NDIM * NPHASE ), intent( inout ) :: U_ABSORB
      REAL, DIMENSION( TOTELE, NDIM, NDIM ), intent( in ) :: PERM2
      REAL, intent( in ) :: MOBILITY
      ! Local variable
      REAL, PARAMETER :: TOLER = 1.E-10
      INTEGER :: ELE, CV_ILOC, CV_NOD, CV_PHA_NOD, MAT_NOD, JPHA_JDIM, &
           IPHA_IDIM, IDIM, JDIM, IPHASE, jphase
      !    integer :: ii
      REAL :: SATURATION
      !    real :: abs_sum
      REAL, DIMENSION( :, :, :), allocatable :: INV_PERM, PERM
      type(corey_options) :: options
      logical :: is_corey, is_land

      ewrite(3,*) 'In calculate_absorption2'
      ALLOCATE( INV_PERM( TOTELE, NDIM, NDIM ))
      ALLOCATE( PERM( TOTELE, NDIM, NDIM ))

      perm=perm2
      do ele = 1, totele
         inv_perm(ele, :, :)=inverse(perm(ele, :, :))
      end do


      U_ABSORB = 0.0

      Loop_NPHASE: DO IPHASE = 1, NPHASE

         is_Corey=.false.
         is_Land=.false.
         if (have_option("/material_phase["// int2str(iphase-1) //&
              "]/multiphase_properties/relperm_type/Corey")) then
            if (nphase==2) then
               is_Corey=.true.
               call get_corey_options(options)
            else
               FLAbort('Attempting to use twophase relperm function with '//int2str(nphase)//' phase(s)')
            end if
         elseif (have_option("/material_phase["// int2str(iphase-1) //"]/multiphase_properties/relperm_type/Land")) then
            if (nphase==2) then
               is_Land=.true.
               call get_land_options(options)
            else
               FLAbort('Attempting to use twophase relperm function with '//int2str(nphase)//' phase(s)')
            end if
         end if

      Loop_ELE: DO ELE = 1, TOTELE

         Loop_CVNLOC: DO CV_ILOC = 1, CV_NLOC

            MAT_NOD = MAT_NDGLN(( ELE - 1 ) * MAT_NLOC + CV_ILOC)
            CV_NOD = CV_NDGLN(( ELE - 1) * CV_NLOC + CV_ILOC )

               Loop_DimensionsI: DO IDIM = 1, NDIM

                  Loop_DimensionsJ: DO JDIM = 1, NDIM

                     CV_PHA_NOD = CV_NOD + ( IPHASE - 1 ) * CV_NONODS
                     SATURATION = SATURA( CV_PHA_NOD ) 
                     IPHA_IDIM = ( IPHASE - 1 ) * NDIM + IDIM 
                     JPHA_JDIM = ( IPHASE - 1 ) * NDIM + JDIM 


                     if (is_corey) then
                        CALL relperm_corey( U_ABSORB( MAT_NOD, IPHA_IDIM, JPHA_JDIM ), MOBILITY, &
                             INV_PERM( ELE, IDIM, JDIM ), min(1.0,max(0.0,SATURA(CV_NOD))), IPHASE,&
                             options)
                     else if (is_land) then
                        CALL relperm_land( U_ABSORB( MAT_NOD, IPHA_IDIM, JPHA_JDIM ), MOBILITY, &
                             INV_PERM( ELE, IDIM, JDIM ), min(1.0,max(0.0,SATURA(CV_NOD))), IPHASE,&
                             options)
                     else
                        U_ABSORB( MAT_NOD, IPHA_IDIM, JPHA_JDIM ) = 0.0

                        !FLAbort('Unknown relperm_type')

                        !                      CASE( 0 ) 
                        ! no absorption option
                        !                         U_ABSORB( MAT_NOD, IPHA_IDIM, JPHA_JDIM ) = 0.0
                        !                      CASE( 1 )
                        !                         U_ABSORB( MAT_NOD, IPHA_IDIM, JPHA_JDIM ) = INV_PERM( ELE, IDIM, JDIM )

                        !                      CASE( 2 ) ! A standard polynomial representation of relative permeability             
                        !                         ABS_SUM = 0.
                        !                         DO II = 1, NUABS_COEFS
                        !                            ABS_SUM = ABS_SUM + UABS_COEFS( IPHASE, II) * SATURATION** (II - 1 )
                        !                         END DO
                        !                         U_ABSORB( MAT_NOD, IPHA_IDIM, JPHA_JDIM ) = INV_PERM( ELE, IDIM, JDIM ) / &
                        !                              MAX( TOLER, ABS_SUM )

                        !                      CASE( 4 ) 
                        !                         ABS_SUM = 0.0
                        !                         DO II = 1, NUABS_COEFS
                        !                            ABS_SUM = ABS_SUM + UABS_COEFS( IPHASE, II) * SATURATION** (II - 1 )
                        !                         U_ABSORB( MAT_NOD, IPHA_IDIM, JPHA_JDIM ) = ABS_SUM
                     endif
                  END DO Loop_DimensionsJ

               END DO Loop_DimensionsI

            END DO Loop_CVNLOC

         END DO Loop_ELE

      END DO Loop_NPHASE

      DEALLOCATE( PERM, INV_PERM )

      ewrite(3,*) 'Leaving calculate_absorption2'

      RETURN

    END SUBROUTINE calculate_absorption2
    

    subroutine initialize_drag_matrix(absorption,state,nphase)
      type(block_csr_matrix), intent(inout) :: absorption
      type(state_type) :: state
      integer :: nphase

      type(vector_field), pointer :: velocity
      type(scalar_field), pointer :: volume_fraction
      type(csr_sparsity), pointer :: sparsity

      
      

      velocity=>extract_vector_field(state,"Velocity")
      volume_fraction=>extract_scalar_field(state,"PhaseVolumeFraction")

      sparsity => get_csr_sparsity_firstorder(state, volume_fraction%mesh,volume_fraction%mesh)

      call allocate(absorption,sparsity,(/nphase*velocity%dim,nphase*velocity%dim/)&
           ,name='DragAbsorption')

      call zero(absorption)


    end subroutine initialize_drag_matrix

    subroutine add_drag_to_old_style_matrix_and_cleanup(drag_abs_matrix,U_ABSORB,state,&
              MAT_NONODS, CV_NONODS, NPHASE, NDIM, TOTELE, CV_NLOC, MAT_NLOC, &
           CV_NDGLN, MAT_NDGLN)
       type(block_csr_matrix), intent(inout) :: drag_abs_matrix
       real, dimension( :, :, : ), intent( inout ) :: u_absorb
       type(state_type) :: state

       INTEGER, intent( in ) :: MAT_NONODS, CV_NONODS, NPHASE, NDIM, TOTELE, CV_NLOC,MAT_NLOC
       INTEGER, DIMENSION( TOTELE * CV_NLOC ), intent( in ) :: CV_NDGLN
      INTEGER, DIMENSION( TOTELE * MAT_NLOC ), intent( in ) :: MAT_NDGLN

       type(scalar_field), pointer :: volume_fraction
       integer :: ELE,IPHASE,IDIM,JPHASE,JDIM,I,J,MAT_NOD,ICV_LOC
       integer, dimension(:), pointer :: nodes

       volume_fraction=>extract_scalar_field(state,"PhaseVolumeFraction")

       DO ELE=1,TOTELE
          do ICV_LOC=1,CV_NLOC
             MAT_NOD = MAT_NDGLN(( ELE - 1 ) * MAT_NLOC+ICV_LOC)
             nodes=>ele_nodes(volume_fraction,ele)
             DO IPHASE=1,NPHASE
                DO IDIM=1,NDIM
                   I=(IPHASE-1)*NDIM+IDIM
                   DO JPHASE=1,NPHASE
                      DO JDIM=1,NDIM
                         J=(JPHASE-1)*NDIM+JDIM
                         U_ABSORB(MAT_NOD,I,J)=U_ABSORB(MAT_NOD,I,J)+&
                              val(drag_abs_matrix,I,J,nodes(ICV_LOC),nodes(ICV_LOC))
                      end DO
                   end Do
                end DO
             end DO
          end DO
       end do

       call deallocate(drag_abs_matrix)

    end subroutine add_drag_to_old_style_matrix_and_cleanup
      

    subroutine add_drag_term(state,absorption,dispersed_phase,continuous_phase,drag_options)
      type(state_type), dimension(:), intent(inout) :: state
      type(block_csr_matrix), intent(inout) :: absorption
      type(vector_field), pointer :: continuous_velocity, dispersed_velocity 
      integer, intent(in) :: dispersed_phase, continuous_phase
      type(drag_option_type) :: drag_options
      type(scalar_field), pointer :: continuous_volume_fraction, dispersed_volume_fraction
      type(scalar_field) :: ratio

      real :: cval
      integer :: node,ndim, dim,block1,block2, IDIM, stat


      cval=4.0d0*drag_options%coefficient/3.0d0*drag_options%diameter

      continuous_velocity=>extract_vector_field(state(continuous_phase),"Velocity",stat)
      if (stat/=0) then
         FLAbort("Attempting to add drag term, when no velocity in contiuous phase")
      end if
      dispersed_velocity =>extract_vector_field(state(dispersed_phase ),"Velocity",stat)
      if (stat/=0) then
         FLAbort("Attempting to add drag term, when no velocity in dispersed phase")
      end if
      ndim=continuous_velocity%dim

!      call allocate(continuous_volume_fraction,continuous_velocity%mesh,"ContinuousVolumeFraction")
!      call get_nonlinear_volume_fraction(state(continuous_phase),continuous_volume_fraction)
!      call allocate(dispersed_volume_fraction,dispersed_velocity%mesh,"DispersedVolumeFraction")
!      call get_nonlinear_volume_fraction(state(dispersed_phase),dispersed_volume_fraction)
!

      continuous_volume_fraction=>extract_scalar_field(state(continuous_phase),"PhaseVolumeFraction",stat)
      dispersed_volume_fraction=>extract_scalar_field(state(dispersed_phase),"PhaseVolumeFraction",stat)
      call allocate(ratio,continuous_volume_fraction%mesh,"RatioOfVolumeFractions")
      call zero(ratio)
      call set(ratio,continuous_volume_fraction)
      call invert(ratio)
      call bound(ratio,1.0d0,huge(0.0))
      call scale(ratio,dispersed_volume_fraction)


      do IDIM=1,ndim
         block1=(continuous_phase-1)*ndim+IDIM
         block2=(dispersed_phase-1)*ndim+IDIM
         do node=1,node_count(continuous_volume_fraction)
            call addto_diag(absorption,block1,block1,node, cval*ratio%val(node))
            call addto_diag(absorption,block1,block2,node,-cval*ratio%val(node))
            call addto_diag(absorption,block2,block1,node,-cval)
            call addto_diag(absorption,block2,block2,node, cval)
         end do
      end do

    end subroutine add_drag_term
      

    subroutine get_drag_options(phase,state,options)
      integer :: phase
      type(state_type) :: state
      type(drag_option_type) :: options


      call get_option("/material_phase["//int2str(phase-1)//"]/multiphase_properties/drag/diameter", &
           options%diameter, default=0.001)
      call get_option("/material_phase["//int2str(phase-1)//"]/multiphase_properties/drag/coefficient", &
           options%coefficient, default=0.001)

     end subroutine get_drag_options

    subroutine get_corey_options(options)
      type(corey_options) :: options
      !    S_GC = 0.1
      call get_option("/material_phase[0]/multiphase_properties/immobile_fraction", &
           options%s_gc, default=0.1)
      !    S_OR = 0.3
      call get_option("/material_phase[1]/multiphase_properties/immobile_fraction", &
           options%s_or, default=0.3)
      call get_option("/material_phase[0]/multiphase_properties/relperm_type/Corey/relperm_max", &
           options%kr1_max, default=1.0)
      call get_option("/material_phase[1]/multiphase_properties/relperm_type/Corey/relperm_max", &
           options%kr2_max, default=1.0)
      call get_option("/material_phase[0]/multiphase_properties/relperm_type/Corey/relperm_exponent", &
           options%kr1_exp, default=2.0)
      call get_option("/material_phase[1]/multiphase_properties/relperm_type/Corey/relperm_exponent", &
           options%kr2_exp, default=2.0)
      options%boost_at_zero_saturation=have_option("/material_phase[1]/multiphase_properties/relperm_type/Corey/boost_at_zero_saturation")
    end subroutine get_corey_options

    subroutine get_land_options(options)
      type(corey_options) :: options
      !    S_GC = 0.1
      call get_option("/material_phase[0]/multiphase_properties/s_gi", &
           options%s_gi, default=0.1)
      !    S_OR = 0.3
      call get_option("/material_phase[1]/multiphase_properties/cs_gi", &
           options%cs_gi, default=0.3)
      call get_option("/material_phase[1]/multiphase_properties/c", options%c, default=0.3)
      call get_option("/material_phase[0]/multiphase_properties/relperm_type/Corey/relperm_max", &
           options%kr1_max, default=1.0)
      call get_option("/material_phase[1]/multiphase_properties/relperm_type/Corey/relperm_max", &
           options%kr2_max, default=1.0)
      call get_option("/material_phase[0]/multiphase_properties/relperm_type/Corey/relperm_exponent", &
           options%kr1_exp, default=2.0)
      call get_option("/material_phase[1]/multiphase_properties/relperm_type/Corey/relperm_exponent", &
           options%kr2_exp, default=2.0)
    end subroutine get_land_options

    SUBROUTINE relperm_corey( ABSP, MOBILITY, INV_PERM, SAT, IPHASE,options )
      IMPLICIT NONE
      REAL, intent( inout ) :: ABSP
      REAL, intent( in ) :: MOBILITY, SAT, INV_PERM
      INTEGER, intent( in ) :: IPHASE
      type(corey_options), intent(in) :: options
      ! Local variables...
      REAL :: S_GC, S_OR, &
           KR1, KR2, KR, VISC, SATURATION, ABS_SUM, SAT2, &
           kr1_max, kr2_max, kr1_exp, kr2_exp



      s_gc=options%s_gc
      s_or=options%s_or
      kr1_max=options%kr1_max
      kr2_max=options%kr2_max
      kr1_exp=options%kr1_exp
      kr2_exp=options%kr2_exp       

      SATURATION = SAT
      IF( IPHASE == 2 ) SATURATION = 1. - SAT

      IF( SAT < S_GC ) THEN
         KR1 = 0.0
      ELSE IF( SAT > 1. -S_OR ) THEN
         kr1 = kr1_max
      ELSE
         KR1 = ( ( SAT - S_GC) / ( 1. - S_GC - S_OR )) ** kr1_exp
      ENDIF

      SAT2 = 1.0 - SAT
      IF( SAT2 < S_OR ) THEN
         KR2 = 0.0
      ELSEIF( SAT2 > 1. - S_GC ) THEN
         KR2 = kr2_max
      ELSE
         KR2 = ( ( SAT2 - S_OR ) / ( 1. - S_GC - S_OR )) ** kr2_exp
      ENDIF

      IF( IPHASE == 1 ) THEN
         KR = KR1
         VISC = 1.0
      ELSE
         KR = KR2
         VISC = MOBILITY
      ENDIF

      ABS_SUM = KR / MAX( 1.e-6, VISC * max( 0.01, SATURATION ))

      ABSP = INV_PERM / MAX( 1.e-6, ABS_SUM )

      if( iphase == 1 ) then
         ABSP =  min( 1.e+4, ABSP )
         if( saturation < s_gc ) then
            ABSP = ( 1. + max( 100. * ( s_gc - saturation ), 0.0 )) * ABSP
         endif
      else
         if (options%boost_at_zero_saturation) then
            ABSP = min( 4.0e+5, ABSP)
            if(saturation < s_or) then
               ABSP = (1. + max( 100. * ( s_or - saturation ), 0.0 )) * ABSP
               ABSP=ABSP+100000.*exp(30.0*(sat-(1-s_or)))
            endif
         else
            ABSP = min( 1.e+5, ABSP )
            if( saturation < s_or ) then
               ABSP = ( 1. + max( 100. * ( s_or - saturation ), 0.0 )) * ABSP
            endif
         endif
      endif

      RETURN
    END SUBROUTINE relperm_corey


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CHRIS BAKER EDIT
    SUBROUTINE relperm_land( ABSP, MOBILITY, INV_PERM, SAT, IPHASE,options )
      IMPLICIT NONE
      REAL, intent( inout ) :: ABSP
      REAL, intent( in ) :: MOBILITY, SAT, INV_PERM
      INTEGER, intent( in ) :: IPHASE
      ! Local variables...
      REAL :: S_GI, S_GT, S_GF, CS_GI, C
      REAL :: S_GC, S_OR, &
           KR1, KR2, KR, VISC, SATURATION, ABS_SUM, SAT2, &
           kr1_max, kr2_max, kr1_exp, kr2_exp
      type(corey_options) options


      s_gi=options%s_gi
      cs_gi=options%cs_gi
      c=options%c

      SATURATION = SAT
      IF( IPHASE == 2 ) SATURATION = 1. - SAT



      S_GT = S_GI/(1+ CS_GI)

      S_GF = 0.5*( ( S_GI - S_GT) + (( S_GI - S_GT)**2.0 + (4.0/C)*( S_GI - S_GT))**0.5)

      ABSP = S_GF 

      RETURN
    END SUBROUTINE relperm_land

    SUBROUTINE calculate_capillary_pressure( state, CV_NONODS, NPHASE, capillary_pressure, SATURA )

      ! CAPIL_PRES_OPT is the capillary pressure option for deciding what form it might take. 
      ! CAPIL_PRES_COEF( NCAPIL_PRES_COEF, NPHASE, NPHASE ) are the coefficients 
      ! Capillary pressure coefs have the dims CAPIL_PRES_COEF( NCAPIL_PRES_COEF, NPHASE,NPHASE )
      ! used to calulcate the capillary pressure. 

      IMPLICIT NONE
      type(state_type), dimension(:) :: state
      INTEGER, intent( in ) :: CV_NONODS, NPHASE
      REAL, DIMENSION( CV_NONODS * NPHASE ), intent( inout ) :: capillary_pressure
      REAL, DIMENSION( CV_NONODS * NPHASE ), intent( in ) :: SATURA
      ! Local Variables
      INTEGER :: nstates, ncomps, nphases, IPHASE, JPHASE, i, j
      real c, a
      character(len=OPTION_PATH_LEN) option_path, phase_name

      ewrite(3,*) 'In calc_capil_pres'

      nstates = option_count("/material_phase")
      ncomps=0
      do i=1,nstates
         if (have_option("/material_phase[" // int2str(i-1) // "]/is_multiphase_component")) then
            ncomps=ncomps+1
         end if
      end do
      nphases=nstates-ncomps

      if (have_option("/material_phase[0]/multiphase_properties/capillary_pressure/type_Brookes_Corey") ) then

         capillary_pressure = 0.0

         DO IPHASE = 1, NPHASE

            option_path = "/material_phase["//int2str(iphase-1)//"]/multiphase_properties/capillary_pressure/type_Brookes_Corey"
            DO JPHASE = 1, NPHASE

               if (iphase/=jphase) then

                  ! Make sure we're pairing the right fields
                  j=-1
                  do i=0, option_count(trim(option_path)//"/phase")-1
                     call get_option(trim(option_path)//"/phase["//int2str(i)//"]/material_phase_name", phase_name)
                     if (trim(state(jphase)%name) == trim(phase_name)) then
                        j=i
                     endif
                  enddo
                  if (j<0) FLAbort('Capillary pressure phase pair not found')

                  call get_option(trim(option_path)//"/phase["//int2str(j)//"]/c", c)
                  call get_option(trim(option_path)//"/phase["//int2str(j)//"]/a", a)

                  capillary_pressure( 1 + ( IPHASE - 1 ) * CV_NONODS : IPHASE * CV_NONODS ) = &
                       capillary_pressure( 1 + ( IPHASE - 1 ) * CV_NONODS : IPHASE * CV_NONODS ) + &
                       c * &
                       MAX( SATURA( 1 + ( JPHASE - 1 ) * CV_NONODS : JPHASE * CV_NONODS ), 0.0 ) &
                       ** a
               endif

            END DO

         END DO

      else
         FLAbort('Unknown capillary pressure type')
      endif

      RETURN
    END SUBROUTINE calculate_capillary_pressure

    subroutine calculate_u_source_cv(state, cv_nonods, ndim, nphase, den, u_source_cv)
      type(state_type), dimension(:), intent(in) :: state
      integer, intent(in) :: cv_nonods, ndim, nphase
      real, dimension(cv_nonods*nphase), intent(in) :: den
      real, dimension(cv_nonods*ndim*nphase), intent(inout) :: u_source_cv

      type(vector_field), pointer :: gravity_direction
      real, dimension(ndim) :: g
      logical :: have_gravity
      real :: gravity_magnitude
      integer :: idim, iphase, nod, stat

      call get_option( "/physical_parameters/gravity/magnitude", gravity_magnitude, stat )
      have_gravity = ( stat == 0 )

      if( have_gravity ) then
         gravity_direction => extract_vector_field( state( 1 ), 'GravityDirection' )
         g = node_val(gravity_direction, 1) * gravity_magnitude

         u_source_cv = 0.

         do idim = 1, ndim
            do iphase = 1, nphase
               do nod = 1, cv_nonods
                  u_source_cv( nod + (idim-1)*cv_nonods + ndim*cv_nonods*(iphase-1) ) = &
                       den( nod + (iphase-1)*cv_nonods ) * g( idim )
               end do
            end do
         end do

      else
         u_source_cv = 0.
      end if

    end subroutine calculate_u_source_cv

    subroutine calculate_diffusivity(state, ncomp, nphase, ndim, cv_nonods, mat_nonods, &
         mat_nloc, totele, mat_ndgln, ScalarAdvectionField_Diffusion )

      type(state_type), dimension(:), intent(in) :: state
      integer, intent(in) :: ncomp, nphase, ndim, cv_nonods, mat_nonods, mat_nloc, totele
      integer, dimension(totele * mat_nloc), intent(in) :: mat_ndgln 
      real, dimension(mat_nonods, ndim, ndim, nphase), intent(inout) :: ScalarAdvectionField_Diffusion

      type(scalar_field), pointer :: component
      type(tensor_field), pointer :: diffusivity
      integer, dimension(:), pointer :: element_nodes
      integer :: icomp, iphase, idim, stat, ele

      integer :: iloc, mat_iloc

      ScalarAdvectionField_Diffusion = 0.

      if ( ncomp > 1 ) then

         do icomp = 1, ncomp
            do iphase = 1, nphase

               component => extract_scalar_field( state(nphase+icomp), 'ComponentMassFractionPhase' // int2str(iphase) )
               diffusivity => extract_tensor_field( state(nphase+icomp), 'ComponentMassFractionPhase' // int2str(iphase) // 'Diffusivity', stat )

               if ( stat == 0 ) then

                  do ele = 1, totele

                     element_nodes => ele_nodes( component, ele )

                     do iloc = 1, mat_nloc
                        mat_iloc = mat_ndgln( (ele-1)*mat_nloc + iloc )

                        do idim = 1, ndim

                           ScalarAdvectionField_Diffusion( mat_iloc, idim, idim, iphase ) = &
                                ScalarAdvectionField_Diffusion( mat_iloc, idim, idim, iphase ) + &
                                node_val( component, element_nodes(iloc) ) * node_val( diffusivity, idim, idim, element_nodes(iloc) )

                        end do
                     end do
                  end do
               end if

            end do
         end do

      else

         do iphase = 1, nphase
            diffusivity => extract_tensor_field( state(iphase), 'Diffusivity', stat )

            if ( stat == 0 ) then
               do idim = 1, ndim
                  ScalarAdvectionField_Diffusion(:, idim, idim, iphase) = node_val( diffusivity, idim, idim, 1 )
               end do
            end if
         end do

      end if

      return
    end subroutine calculate_diffusivity

    subroutine calculate_viscosity( state, ncomp, nphase, ndim, mat_nonods, mat_ndgln, Momentum_Diffusion  )

      type(state_type), dimension(:), intent(in) :: state
      integer, intent(in) :: ncomp, nphase, ndim, mat_nonods
      integer, dimension(:), intent(in) :: mat_ndgln

      real, dimension( mat_nonods, ndim, ndim, nphase ), intent(inout) :: Momentum_Diffusion
      character( len = option_path_len ) :: option_path
      type(tensor_field), pointer :: t_field
      integer :: iphase, icomp, idim, stat, cv_nod, mat_nod, cv_nloc, ele

      type(scalar_field), pointer :: component, diffusivity
      integer, dimension(:), pointer :: st_nodes

      integer :: iloc

      if ( have_option( '/physical_parameters/mobility' ) ) then

         ! if solving for porous media and mobility is calculated
         ! through the viscosity ratio this code will fail
         momentum_diffusion=0.

      else

         momentum_diffusion=0.

         t_field => extract_tensor_field( state( 1 ), 'Viscosity', stat )
         if ( stat == 0 ) then

            if ( ncomp > 1 ) then

               cv_nloc = ele_loc( t_field, ele )

               do icomp = 1, ncomp
                  do iphase = 1, nphase

                     component => extract_scalar_field( state(nphase + icomp), 'ComponentMassFractionPhase' // int2str(iphase) )
                     t_field => extract_tensor_field( state( nphase + icomp ), 'Viscosity' )

                     do ele = 1, ele_count( t_field )

                        st_nodes => ele_nodes( t_field, ele )

                        do iloc = 1, cv_nloc
                           mat_nod = mat_ndgln( (ele-1)*cv_nloc + iloc )

                           momentum_diffusion( mat_nod, :, :, iphase ) =  momentum_diffusion( mat_nod, :, :, iphase ) + &
                                node_val( t_field, st_nodes(iloc) ) * node_val( component, st_nodes(iloc) )
                        end do
                     end do

                  end do
               end do

            else

               do iphase = 1, nphase

                  t_field => extract_tensor_field( state( iphase ), 'Viscosity', stat )

                  option_path = '/material_phase[' // int2str( iphase - 1 ) // &
                       ']/vector_field::Velocity/prognostic/tensor_field::Viscosity'
                  call Extract_TensorFields_Outof_State( state, iphase, &
                       t_field, option_path, &
                       momentum_diffusion( :, :, :, iphase ), &
                       mat_ndgln )
               end do

            end if

         end if

      end if

      return
    end subroutine calculate_viscosity

    subroutine calculate_SUF_SIG_DIAGTEN_BC( suf_sig_diagten_bc, totele, stotel, cv_nloc, &
         cv_snloc, nphase, ndim, nface, mat_nonods, cv_nonods, x_nloc, ncolele, cv_ele_type, &
         finele, colele, cv_ndgln, cv_sndgln, x_ndgln, mat_ndgln, perm, material_absorption, &
         wic_u_bc, wic_vol_bc, sat, vol, state, x_nonods, x,y,z )

      implicit none

      integer, intent(in) :: totele, stotel, cv_nloc, cv_snloc, nphase, ndim, nface, &
           mat_nonods, cv_nonods, x_nloc, ncolele, cv_ele_type, x_nonods
      integer, dimension( totele+1 ), intent( in ) :: finele
      integer, dimension( ncolele ), intent( in ) :: colele
      integer, dimension( totele * cv_nloc ), intent( in ) :: cv_ndgln
      integer, dimension( stotel * cv_snloc ), intent( in ) :: cv_sndgln
      integer, dimension( totele * x_nloc ), intent( in ) :: x_ndgln
      integer, dimension( totele * cv_nloc ), intent( in ) :: mat_ndgln
      integer, dimension( stotel * nphase ), intent( in ) :: wic_u_bc, wic_vol_bc
      real, dimension( totele, ndim, ndim ), intent( in ) :: perm
      real, dimension( mat_nonods, ndim*nphase, ndim*nphase ), intent( inout ) :: material_absorption
      real, dimension( stotel * cv_snloc * nphase ), intent( in ) :: sat
      real, dimension( cv_nonods * nphase ), intent( in ) :: vol
      real, dimension( x_nonods ), intent( in ) :: x,y,z
      type(state_type), dimension( : ) :: state

      real, dimension( stotel * cv_snloc * nphase, ndim ), intent( inout ) :: suf_sig_diagten_bc

      ! local variables
      type(tensor_field), pointer :: viscosity_ph1, viscosity_ph2
      integer :: iphase, ele, sele, cv_siloc, cv_snodi, cv_snodi_ipha, iface, s, e, &
           ele2, sele2, cv_iloc, idim, jdim, i, mat_nod
      real :: mobility, satura_bc
      real, dimension( ndim, ndim ) :: inv_perm, sigma_out, mat, mat_inv
      integer, dimension( :, : ), allocatable :: cv_sloclist, face_ele
      integer, dimension( : ), allocatable :: idone
      integer, dimension( cv_snloc ) :: cv_sloc2loc
      integer, parameter :: WIC_BC_DIRICHLET = 1
!!$ for the pressure b.c. and overlapping method 
!!$ make the material property change just inside the domain else on the surface only...
      logical, parameter :: mat_change_inside = .true.
      logical :: is_land, is_corey

      type(corey_options) :: options

      if( have_option( '/physical_parameters/mobility' ) )then
         call get_option( '/physical_parameters/mobility', mobility )
      elseif( have_option( '/material_phase[1]/vector_field::Velocity/prognostic/tensor_field::Viscosity' // &
           '/prescribed/value::WholeMesh/isotropic' ) ) then
         viscosity_ph1 => extract_tensor_field( state( 1 ), 'Viscosity' )
         viscosity_ph2 => extract_tensor_field( state( 2 ), 'Viscosity' )
         mobility = viscosity_ph2%val( 1, 1, 1 ) / viscosity_ph1%val( 1, 1, 1 )
      elseif( nphase == 1 ) then
         mobility = 0.
      end if

      suf_sig_diagten_bc = 1.

      allocate( idone( mat_nonods*nphase ) ) ; idone=0
      allocate( cv_sloclist( nface, cv_snloc ) )
      call determin_sloclist( cv_sloclist, cv_nloc, cv_snloc, nface,  &
           ndim, cv_ele_type )

      allocate( face_ele( nface, totele ) ) ; face_ele = 0
      call calc_face_ele( face_ele, totele, stotel, nface, &
           ncolele, finele, colele, cv_nloc, cv_snloc, cv_nonods, cv_ndgln, cv_sndgln, &
           cv_sloclist, x_nloc, x_ndgln )


      do iphase = 1, nphase

         s = ( iphase - 1 ) * ndim + 1
         e = iphase * ndim

         is_corey=.false.
         is_land=.false.

         if ( have_option("/material_phase["// int2str(iphase-1) //&
              "]/multiphase_properties/relperm_type/Corey") ) then
            is_corey=.true.
            call get_corey_options(options)
         elseif ( have_option("/material_phase["// int2str(iphase-1) //&
                                   "]/multiphase_properties/relperm_type/Land") ) then
            is_land=.true.
            call get_land_options(options)
         end if

         do ele = 1, totele

            inv_perm = inverse( perm(ele, :, :) )

            do iface = 1, nface

               ele2  = face_ele( iface, ele )
               sele2 = max( 0, -ele2 )
               sele  = sele2

               if ( sele > 0 ) then
                  if ( wic_u_bc( sele + ( iphase - 1 ) * stotel ) /= WIC_BC_DIRICHLET .and. &
                     wic_vol_bc( sele + ( iphase - 1 ) * stotel ) == WIC_BC_DIRICHLET ) then

                     cv_sloc2loc( : ) = cv_sloclist( iface, : )

                     do cv_siloc = 1, cv_snloc

                        cv_iloc = cv_sloc2loc( cv_siloc )
                        cv_snodi = ( sele - 1 ) * cv_snloc + cv_siloc
                        cv_snodi_ipha = cv_snodi + ( iphase - 1 ) * stotel * cv_snloc
                        mat_nod = mat_ndgln( (ele-1)*cv_nloc + cv_iloc  )

                        ! this is the boundary condition
                        ! of the first phase
                        satura_bc = sat( cv_snodi )

                        sigma_out = 0.
                        do idim = 1, ndim
                           do jdim = 1, ndim
                              if (is_corey) then
                                 call relperm_corey( sigma_out( idim, jdim ), mobility, &
                                      inv_perm( idim, jdim ), satura_bc, iphase,options)

                              elseif (is_land) then

                                 call relperm_land( sigma_out( idim, jdim ), mobility, &
                                      inv_perm( idim, jdim ), satura_bc, iphase,options )

                              end if
                           end do
                        end do

                        mat = matmul( sigma_out, inverse( material_absorption( mat_nod, s : e, s : e ) ) )
                        mat_inv = inverse( mat )
                        suf_sig_diagten_bc( cv_snodi_ipha, 1 : ndim ) = (/ (mat_inv(i, i), i = 1, ndim) /)

                        if( mat_change_inside ) then
                           suf_sig_diagten_bc( cv_snodi_ipha, 1 : ndim ) = 1.

                           if( idone( mat_nod+(iphase-1)*mat_nonods ) == 0 ) then
                              material_absorption( mat_nod, s : e, s : e  ) &
                                 = matmul( mat, material_absorption( mat_nod, s : e, s : e ) )
                              idone( mat_nod+(iphase-1)*mat_nonods ) = 1
                           end if
                        end if

                     end do

                  end if
               end if

            end do
         end do

      end do

      deallocate( face_ele, cv_sloclist )

      return
    end subroutine calculate_SUF_SIG_DIAGTEN_BC


    subroutine calculate_u_abs_stab( Material_Absorption_Stab, Material_Absorption, &
         opt_vel_upwind_coefs, nphase, ndim, totele, cv_nloc, mat_nloc, mat_nonods, mat_ndgln )

      implicit none

      real, dimension( mat_nonods, ndim * nphase, ndim * nphase ), intent( inout ) :: Material_Absorption_Stab
      real, dimension( mat_nonods, ndim * nphase, ndim * nphase ), intent( in ) :: Material_Absorption
      real, dimension( mat_nonods * nphase * ndim * ndim * 2 ), intent( in ) :: opt_vel_upwind_coefs
      integer, intent( in ) :: nphase, ndim, totele, cv_nloc, mat_nloc, mat_nonods
      integer, dimension( totele * mat_nloc ), intent( in ) :: mat_ndgln

      logical :: use_mat_stab_stab
      integer :: apply_dim, idim, jdim, ipha_idim, iphase, ele, cv_iloc, ij, imat
      real :: factor

      Material_Absorption_Stab = 0.

      use_mat_stab_stab = .false.

      if ( use_mat_stab_stab ) then

         apply_dim = 2

         if ( .true. ) then

            factor = 100.

            do iphase = 1, nphase
               do idim = 1, ndim
                  if ( idim == apply_dim ) then
                     ipha_idim = ( iphase - 1 ) * ndim + idim
                     Material_Absorption_Stab( :, ipha_idim, ipha_idim ) = &
                          ( factor / 10. )**2 * Material_Absorption( :, ipha_idim, ipha_idim )
                  end if
               end do
            end do

         else

            do ele = 1, totele
               do cv_iloc = 1, cv_nloc
                  imat = mat_ndgln( ( ele - 1 ) * mat_nloc + cv_iloc )
                  do iphase = 1, nphase
                     do idim = 1, ndim
                        do jdim = 1, ndim
                           if ( idim == apply_dim .and. jdim == apply_dim ) then
                              ij = ( iphase - 1 ) * mat_nonods * ndim * ndim + ( imat - 1 ) * ndim * ndim + &
                                   ( idim - 1 ) * ndim + jdim
                              ipha_idim = ( iphase - 1 ) * ndim + idim
                              Material_Absorption_Stab( imat, ipha_idim, ipha_idim ) = &
                                   abs( opt_vel_upwind_coefs( ij + nphase * mat_nonods * ndim * ndim ) )
                           end if
                        end do
                     end do
                  end do
               end do
            end do

         end if
      end if ! use_mat_stab_stab

      return
    end subroutine calculate_u_abs_stab


  end module multiphase_EOS
